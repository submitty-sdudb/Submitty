import socket
import sys
import csv
import traceback
import queue
import errno
from time import sleep
import os
import datetime
import random
from datetime import timedelta  

class submitty_router():
  '''
  A constructor for the standard router, set seed to a positive integer to
    make a number of router functions deterministic run-on-run.
  '''
  def __init__(self, seed=None, log_file='router_log.txt'):
    if seed != None:
      random.seed( seed )
    # Variable to keep track of how many messages we have intercepted so far.
    self.messages_intercepted = 0
    # Initialized when run is called.
    self.execution_start_time = None
    self.log_file = log_file
    self.sequence_diagram_file = 'sequence_diagram.txt'
    self.switchboard = {}
    self.ports = list()
    self.p_queue = queue.PriorityQueue()
    self.running = False

  ##################################################################################################################
  # INSTRUCTOR FUNCTIONS
  ##################################################################################################################
  
  '''
  Override this function to manipulate student messages.

  data has the following keys:
  1. sender: The node that sent the message.
  2. recipient: The node to which the message is bound
  3. port: The port on which the message was received and will be sent.
  4. message: The message that was passed.
  5. message_number: The sequence number of the message as it was received by the router.
  6. receipt_time: The time at which the message was received by the router (sent by the sender)
  7. forward_time: The time at which the message is scheduled to be forwarded by the router to the recipient.
     Defaults to be equivalent to receipt_time.
  8. time_since_test_start: how long the test has currently been running as a timedelta object. 
  9. drop_message: A boolean, which, if true, states that the message will be dropped.
     Defaults to false.
  10. diagram_label: A label for this message on the sequence diagram generated by this testcase
     Defaults to None
  '''
  def manipulate_received_message(self, data):
    return data


  ##################################################################################################################
  # LOGGING FUNCTIONS
  ##################################################################################################################
  def convert_queue_obj_to_string(self, obj):
    str = '\tSENDER: {0}\n\tRECIPIENT: {1}\n\tPORT: {2}\n\tCONTENT: {3}'.format(obj['sender'], obj['recipient'], obj['port'], obj['message'])
    return str

  def log(self, line):
    if os.path.exists(self.log_file):
      append_write = 'a' # append if already exists
    else:
        append_write = 'w' # make a new file if not
    with open(self.log_file, mode=append_write) as out_file:
      out_file.write(line + '\n')
      out_file.flush()
    print(line)
    sys.stdout.flush()

  def write_sequence_file(self, obj, status, message_type):
    append_write = 'a' if os.path.exists(self.sequence_diagram_file) else 'w'

    #select the proper arrow type for the message
    if status == 'success':
      arrow = '->>' if message_type == 'tcp' else '-->>'
    else:
      arrow = '-x' if message_type == 'tcp' else '--x'

    sender = obj['sender'].replace('_Actual', '')
    recipient = obj['recipient'].replace('_Actual', '')

    with open(self.sequence_diagram_file, append_write) as outfile:
      outfile.write('{0}{1}{2}: {3}\n'.format(sender, arrow, recipient, str(obj['message'])))
      if 'diagram_label' in obj and obj['diagram_label'] != None and obj['diagram_label'].strip() != '':
        outfile.write('Note over {0},{1}: {2}\n'.format(sender, recipient, obj['diagram_label']))


  ##################################################################################################################
  # SWITCHBOARD FUNCTION
  ##################################################################################################################

  '''
  knownhosts_tcp.txt and knownhosts_udp.txt are of the form
  sender recipient port_number
  such that sender sends all communications to recipient via port_number. 
  '''
  def build_switchboard(self):
    try:
      #Read the known_hosts.csv see the top of the file for the specification
      for connection_type in ["tcp", "udp"]:
        filename = 'knownhosts_{0}.txt'.format(connection_type)
        with open(filename, 'r') as infile:
          content = infile.readlines()    
          
        for line in content:
          sender, recipient, port = line.split()
          #Strip away trailing or leading whitespace
          sender = '{0}_Actual'.format(sender.strip())
          recipient = '{0}_Actual'.format(recipient.strip())
          port = port.strip()

          if not port in self.ports:
            self.ports.append(port)
          else:
            raise SystemExit("ERROR: port {0} was encountered twice. Please keep all ports independant.".format(port))

          self.switchboard[port] = {}
          self.switchboard[port]['connection_type'] = connection_type
          self.switchboard[port]['sender'] = sender
          self.switchboard[port]['recipient'] = recipient
          self.switchboard[port]['connected'] = False
          self.switchboard[port]['connection'] = None
    except IOError as e:
      self.log("ERROR: Could not read {0}.".format(filename))
      self.log(traceback.format_exc())
    except ValueError as e:
      self.log("ERROR: {0} was improperly formatted. Please include lines of the form (SENDER, RECIPIENT, PORT)".format(filename))
    except Exception as e:
      self.log('Encountered an error while reading and parsing {0}'.format(filename))
      self.log(traceback.format_exc())


  ##################################################################################################################
  # OUTGOING CONNECTION/QUEUE FUNCTIONS
  ##################################################################################################################


  def connect_outgoing_socket(self, port):
    if self.switchboard[port]['connected']:
      return

    connection_type = self.switchboard[port]["connection_type"]

    recipient = self.switchboard[port]['recipient']
    server_address = (recipient, int(port))

    if connection_type == 'tcp':
      sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      sock.connect(server_address)
    else:
      sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    #We catch errors one level up.
    name = recipient.replace('_Actual', '')
    self.log("Established outgoing connection to {0} on port {1}".format(name, port))
    self.switchboard[port]['connected'] = True
    self.switchboard[port]['outgoing_socket'] = sock

  def send_outgoing_message(self, data):
    status = 'unset'
    message_type = 'unset'
    try:
      drop_message = data.get('drop_message', False)
      port = data['port']
      message = data['message']
      sock = self.switchboard[port]['outgoing_socket']
      recipient = data['recipient']
    except:
      status = 'router_error'
      self.log("An error occurred internal to the router. Please report the following error to a Submitty Administrator")
      self.log(traceback.format_exc())
      self.write_sequence_file(data, status, message_type)
      return
    try:
      message_type = self.switchboard[port]['connection_type']
      if drop_message:
        success = "dropped"
        self.log("Choosing not to deliver message {!r} to {}".format(message, recipient.replace('_Actual', '')))
      elif message_type == 'tcp':
        sock.sendall(message)
        self.log('Sent message {!r} to {}'.format(message,recipient.replace('_Actual', '')))
        status = 'success'
      else:
        destination_address = (recipient, int(port))
        sock.sendto(message,destination_address)
        self.log('Sent message {!r} to {}'.format(message,recipient.replace('_Actual', '')))
        status = 'success'
    except:
      self.log('Could not deliver message {!r} to {}'.format(message,recipient))
      self.switchboard[port]['connected'] = False
      self.switchboard[port]['connection'].close()
      self.switchboard[port]['connection'] = None
      status = 'failure'
    self.write_sequence_file(data, status, message_type)

  def process_queue(self):
    # The still_going variable/loop protects us against multiple 
    #  enqueued items with the same send time.
    still_going = True
    while still_going:
      try:
        now = datetime.datetime.now()
        #priority queue has no peek function due to threading issues.
        #  as a result, pull it off, check it, then put it back on.
        value = self.p_queue.get_nowait()
        if value[0] <= now:
          self.send_outgoing_message(value[1])
        else:
          self.p_queue.put(value)
          still_going = False
      except queue.Empty:
        still_going = False


  ##################################################################################################################
  # INCOMING CONNECTION FUNCTIONS
  ##################################################################################################################

  def connect_incoming_sockets(self):
    for port in self.ports:
      self.open_incoming_socket(port)

  def open_incoming_socket(self, port):
    # Create a TCP/IP socket

    connection_type = self.switchboard[port]['connection_type']
    sender = self.switchboard[port]['sender']

    if connection_type == "tcp":
      sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    elif connection_type == "udp":
      sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    else:
      self.log("ERROR: bad connection type {0}. Please contact an administrator".format(connection_type))
      sys.exit(1)

    #Bind the socket to the port
    server_address = ('', int(port))
    sock.bind(server_address)
    sock.setblocking(False)

    self.log('Bound socket port {0}'.format(port))

    if connection_type == 'tcp':
      #listen for at most 1 incoming connections at a time.
      sock.listen(1)

    self.switchboard[port]['incoming_socket'] = sock

    if connection_type == 'udp':
      self.switchboard[port]['connection'] = sock

  def listen_to_sockets(self):
    for port in self.ports:
      try:
        connection_type = self.switchboard[port]["connection_type"]
        if connection_type == 'tcp':
          if self.switchboard[port]["connection"] == None:
            sock = self.switchboard[port]['incoming_socket']
            # Accept the message
            connection, client_address = sock.accept()
            # Set the connection to non_blocking
            connection.setblocking(False)
            self.switchboard[port]['connection'] = connection
            name = self.switchboard[port]['sender'].replace('_Actual', '')
            self.log('established connection with {0} on port {1}'.format(name, port))
          else:
            connection = self.switchboard[port]['connection']
        elif connection_type == 'udp':
            connection = self.switchboard[port]["connection"]
        else:
          self.log('Invalid connection type {0}. Please contact an administrator with this error.'.format(connection_type))
          sys.exit(1)

        #TODO: May have to the max recvfrom size.
        #The recvfrom call will raise a OSError if there is nothing to receive. 
        message, snd = connection.recvfrom(4096)
        sender = self.switchboard[port]['sender'].replace("_Actual", "")

        if message.decode('utf-8') == '' and connection_type == 'tcp':
          self.log('Host {0} disconnected on port {1}.'.format(sender,port))
          self.switchboard[port]['connected'] = False
          self.switchboard[port]['connection'].close()
          self.switchboard[port]['connection'] = None
          continue

        self.log('Received message {!r} from {} on port {}'.format(message,sender,port))

        #if we did not error:
        self.connect_outgoing_socket(port)
        recipient = self.switchboard[port]['recipient']
        
        self.messages_intercepted += 1

        now = datetime.datetime.now()
        data = {
          'sender' : sender,
          'recipient' : recipient, 
          'port' : port,
          'message' : message,
          'message_number' : self.messages_intercepted,
          'receipt_time' : now,
          'forward_time' : now,
          'time_since_test_start' : now - self.execution_start_time,
          'drop_message' : False,
          'diagram_label' : None
        }
        
        tup = self.manipulate_received_message(data)

        self.p_queue.put((data['forward_time'], data))
      except socket.timeout as e:
        #This is likely an acceptable error caused by non-blocking sockets having nothing to read.
        err = e.args[0]
        if err == 'timed out':
          self.log('no data')
        else:
          self.log('real error!')
          self.log(traceback.format_exc())
      except BlockingIOError as e:
        pass
      except ConnectionRefusedError as e:
        #this means that connect_outgoing_tcp didn't work.
        self.log('Connection on outgoing channel not established. Message dropped.')
        self.log(traceback.format_exc())
        self.switchboard[port]['connected'] = False
      except socket.gaierror as e:
        self.log("Unable to connect to unknown/not set up entity.")
        self.log(traceback.format_exc())
      except Exception as e:
        self.log("ERROR: error listening to socket {0}".format(port))
        self.log(traceback.format_exc())


  ##################################################################################################################
  # CONTROL FUNCTIONS
  ##################################################################################################################


  #Do everything that should happen before multiprocessing kicks in.
  def init(self):
    self.log('Booting up the router...')
    self.build_switchboard()
    #Only supporting tcp at the moment.
    self.log('Connecting incoming sockets...')
    self.connect_incoming_sockets()

  def run(self):
    self.running = True
    #sleep(1)
    self.execution_start_time = datetime.datetime.now()
    self.log('Listening for incoming connections...')
    while self.running:
      self.listen_to_sockets()
      self.process_queue()


if __name__ == '__main__':
  router = submitty_router()
  router.init()
  router.run()

